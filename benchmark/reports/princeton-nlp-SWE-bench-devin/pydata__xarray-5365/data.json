{
  "instance_id": "pydata__xarray-5365",
  "model_patch": "diff --git a/xarray/core/ops.py b/xarray/core/ops.py\nindex 8265035a..6b11446c 100644\n--- a/xarray/core/ops.py\n+++ b/xarray/core/ops.py\n@@ -330,3 +330,42 @@ class IncludeNumpySameMethods:\n         super().__init_subclass__(**kwargs)\n \n         inject_numpy_same(cls)  # some methods not applicable to Dataset objects\n+\n+\n+def cross(a, b, spatial_dim):\n+    \"\"\"\n+    Compute the cross product of two DataArray objects along a specified dimension.\n+\n+    Parameters\n+    ----------\n+    a : DataArray\n+        The first input array.\n+    b : DataArray\n+        The second input array.\n+    spatial_dim : str\n+        The name of the dimension along which to compute the cross product.\n+\n+    Returns\n+    -------\n+    DataArray\n+        The cross product of the input arrays computed along the specified dimension.\n+    \"\"\"\n+    from .computation import apply_ufunc\n+\n+    if spatial_dim not in a.dims or spatial_dim not in b.dims:\n+        raise ValueError(f\"dimension {spatial_dim} not in both input DataArrays\")\n+\n+    if a.sizes[spatial_dim] != 3 or b.sizes[spatial_dim] != 3:\n+        raise ValueError(\n+            f\"dimension {spatial_dim} does not have size 3 in both input DataArrays\"\n+        )\n+\n+    return apply_ufunc(\n+        np.cross,\n+        a,\n+        b,\n+        input_core_dims=[[spatial_dim], [spatial_dim]],\n+        output_core_dims=[[spatial_dim]],\n+        dask=\"parallelized\",\n+        output_dtypes=[a.dtype],\n+    )\n",
  "model_name_or_path": "Devin",
  "pass_or_fail": "fail",
  "model_patch_files": [
    "xarray/core/ops.py"
  ],
  "repo": "pydata/xarray",
  "base_commit": "3960ea3ba08f81d211899827612550f6ac2de804",
  "patch": "diff --git a/xarray/__init__.py b/xarray/__init__.py\n--- a/xarray/__init__.py\n+++ b/xarray/__init__.py\n@@ -16,7 +16,16 @@\n from .core.alignment import align, broadcast\n from .core.combine import combine_by_coords, combine_nested\n from .core.common import ALL_DIMS, full_like, ones_like, zeros_like\n-from .core.computation import apply_ufunc, corr, cov, dot, polyval, unify_chunks, where\n+from .core.computation import (\n+    apply_ufunc,\n+    corr,\n+    cov,\n+    cross,\n+    dot,\n+    polyval,\n+    unify_chunks,\n+    where,\n+)\n from .core.concat import concat\n from .core.dataarray import DataArray\n from .core.dataset import Dataset\n@@ -60,6 +69,7 @@\n     \"dot\",\n     \"cov\",\n     \"corr\",\n+    \"cross\",\n     \"full_like\",\n     \"get_options\",\n     \"infer_freq\",\ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -36,6 +36,7 @@\n \n if TYPE_CHECKING:\n     from .coordinates import Coordinates\n+    from .dataarray import DataArray\n     from .dataset import Dataset\n     from .types import T_Xarray\n \n@@ -1373,6 +1374,214 @@ def _cov_corr(da_a, da_b, dim=None, ddof=0, method=None):\n         return corr\n \n \n+def cross(\n+    a: Union[DataArray, Variable], b: Union[DataArray, Variable], *, dim: Hashable\n+) -> Union[DataArray, Variable]:\n+    \"\"\"\n+    Compute the cross product of two (arrays of) vectors.\n+\n+    The cross product of `a` and `b` in :math:`R^3` is a vector\n+    perpendicular to both `a` and `b`. The vectors in `a` and `b` are\n+    defined by the values along the dimension `dim` and can have sizes\n+    1, 2 or 3. Where the size of either `a` or `b` is\n+    1 or 2, the remaining components of the input vector is assumed to\n+    be zero and the cross product calculated accordingly. In cases where\n+    both input vectors have dimension 2, the z-component of the cross\n+    product is returned.\n+\n+    Parameters\n+    ----------\n+    a, b : DataArray or Variable\n+        Components of the first and second vector(s).\n+    dim : hashable\n+        The dimension along which the cross product will be computed.\n+        Must be available in both vectors.\n+\n+    Examples\n+    --------\n+    Vector cross-product with 3 dimensions:\n+\n+    >>> a = xr.DataArray([1, 2, 3])\n+    >>> b = xr.DataArray([4, 5, 6])\n+    >>> xr.cross(a, b, dim=\"dim_0\")\n+    <xarray.DataArray (dim_0: 3)>\n+    array([-3,  6, -3])\n+    Dimensions without coordinates: dim_0\n+\n+    Vector cross-product with 2 dimensions, returns in the perpendicular\n+    direction:\n+\n+    >>> a = xr.DataArray([1, 2])\n+    >>> b = xr.DataArray([4, 5])\n+    >>> xr.cross(a, b, dim=\"dim_0\")\n+    <xarray.DataArray ()>\n+    array(-3)\n+\n+    Vector cross-product with 3 dimensions but zeros at the last axis\n+    yields the same results as with 2 dimensions:\n+\n+    >>> a = xr.DataArray([1, 2, 0])\n+    >>> b = xr.DataArray([4, 5, 0])\n+    >>> xr.cross(a, b, dim=\"dim_0\")\n+    <xarray.DataArray (dim_0: 3)>\n+    array([ 0,  0, -3])\n+    Dimensions without coordinates: dim_0\n+\n+    One vector with dimension 2:\n+\n+    >>> a = xr.DataArray(\n+    ...     [1, 2],\n+    ...     dims=[\"cartesian\"],\n+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\"])),\n+    ... )\n+    >>> b = xr.DataArray(\n+    ...     [4, 5, 6],\n+    ...     dims=[\"cartesian\"],\n+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"])),\n+    ... )\n+    >>> xr.cross(a, b, dim=\"cartesian\")\n+    <xarray.DataArray (cartesian: 3)>\n+    array([12, -6, -3])\n+    Coordinates:\n+      * cartesian  (cartesian) <U1 'x' 'y' 'z'\n+\n+    One vector with dimension 2 but coords in other positions:\n+\n+    >>> a = xr.DataArray(\n+    ...     [1, 2],\n+    ...     dims=[\"cartesian\"],\n+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"z\"])),\n+    ... )\n+    >>> b = xr.DataArray(\n+    ...     [4, 5, 6],\n+    ...     dims=[\"cartesian\"],\n+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"])),\n+    ... )\n+    >>> xr.cross(a, b, dim=\"cartesian\")\n+    <xarray.DataArray (cartesian: 3)>\n+    array([-10,   2,   5])\n+    Coordinates:\n+      * cartesian  (cartesian) <U1 'x' 'y' 'z'\n+\n+    Multiple vector cross-products. Note that the direction of the\n+    cross product vector is defined by the right-hand rule:\n+\n+    >>> a = xr.DataArray(\n+    ...     [[1, 2, 3], [4, 5, 6]],\n+    ...     dims=(\"time\", \"cartesian\"),\n+    ...     coords=dict(\n+    ...         time=([\"time\"], [0, 1]),\n+    ...         cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"]),\n+    ...     ),\n+    ... )\n+    >>> b = xr.DataArray(\n+    ...     [[4, 5, 6], [1, 2, 3]],\n+    ...     dims=(\"time\", \"cartesian\"),\n+    ...     coords=dict(\n+    ...         time=([\"time\"], [0, 1]),\n+    ...         cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"]),\n+    ...     ),\n+    ... )\n+    >>> xr.cross(a, b, dim=\"cartesian\")\n+    <xarray.DataArray (time: 2, cartesian: 3)>\n+    array([[-3,  6, -3],\n+           [ 3, -6,  3]])\n+    Coordinates:\n+      * time       (time) int64 0 1\n+      * cartesian  (cartesian) <U1 'x' 'y' 'z'\n+\n+    Cross can be called on Datasets by converting to DataArrays and later\n+    back to a Dataset:\n+\n+    >>> ds_a = xr.Dataset(dict(x=(\"dim_0\", [1]), y=(\"dim_0\", [2]), z=(\"dim_0\", [3])))\n+    >>> ds_b = xr.Dataset(dict(x=(\"dim_0\", [4]), y=(\"dim_0\", [5]), z=(\"dim_0\", [6])))\n+    >>> c = xr.cross(\n+    ...     ds_a.to_array(\"cartesian\"), ds_b.to_array(\"cartesian\"), dim=\"cartesian\"\n+    ... )\n+    >>> c.to_dataset(dim=\"cartesian\")\n+    <xarray.Dataset>\n+    Dimensions:  (dim_0: 1)\n+    Dimensions without coordinates: dim_0\n+    Data variables:\n+        x        (dim_0) int64 -3\n+        y        (dim_0) int64 6\n+        z        (dim_0) int64 -3\n+\n+    See Also\n+    --------\n+    numpy.cross : Corresponding numpy function\n+    \"\"\"\n+\n+    if dim not in a.dims:\n+        raise ValueError(f\"Dimension {dim!r} not on a\")\n+    elif dim not in b.dims:\n+        raise ValueError(f\"Dimension {dim!r} not on b\")\n+\n+    if not 1 <= a.sizes[dim] <= 3:\n+        raise ValueError(\n+            f\"The size of {dim!r} on a must be 1, 2, or 3 to be \"\n+            f\"compatible with a cross product but is {a.sizes[dim]}\"\n+        )\n+    elif not 1 <= b.sizes[dim] <= 3:\n+        raise ValueError(\n+            f\"The size of {dim!r} on b must be 1, 2, or 3 to be \"\n+            f\"compatible with a cross product but is {b.sizes[dim]}\"\n+        )\n+\n+    all_dims = list(dict.fromkeys(a.dims + b.dims))\n+\n+    if a.sizes[dim] != b.sizes[dim]:\n+        # Arrays have different sizes. Append zeros where the smaller\n+        # array is missing a value, zeros will not affect np.cross:\n+\n+        if (\n+            not isinstance(a, Variable)  # Only used to make mypy happy.\n+            and dim in getattr(a, \"coords\", {})\n+            and not isinstance(b, Variable)  # Only used to make mypy happy.\n+            and dim in getattr(b, \"coords\", {})\n+        ):\n+            # If the arrays have coords we know which indexes to fill\n+            # with zeros:\n+            a, b = align(\n+                a,\n+                b,\n+                fill_value=0,\n+                join=\"outer\",\n+                exclude=set(all_dims) - {dim},\n+            )\n+        elif min(a.sizes[dim], b.sizes[dim]) == 2:\n+            # If the array doesn't have coords we can only infer\n+            # that it has composite values if the size is at least 2.\n+            # Once padded, rechunk the padded array because apply_ufunc\n+            # requires core dimensions not to be chunked:\n+            if a.sizes[dim] < b.sizes[dim]:\n+                a = a.pad({dim: (0, 1)}, constant_values=0)\n+                # TODO: Should pad or apply_ufunc handle correct chunking?\n+                a = a.chunk({dim: -1}) if is_duck_dask_array(a.data) else a\n+            else:\n+                b = b.pad({dim: (0, 1)}, constant_values=0)\n+                # TODO: Should pad or apply_ufunc handle correct chunking?\n+                b = b.chunk({dim: -1}) if is_duck_dask_array(b.data) else b\n+        else:\n+            raise ValueError(\n+                f\"{dim!r} on {'a' if a.sizes[dim] == 1 else 'b'} is incompatible:\"\n+                \" dimensions without coordinates must have have a length of 2 or 3\"\n+            )\n+\n+    c = apply_ufunc(\n+        np.cross,\n+        a,\n+        b,\n+        input_core_dims=[[dim], [dim]],\n+        output_core_dims=[[dim] if a.sizes[dim] == 3 else []],\n+        dask=\"parallelized\",\n+        output_dtypes=[np.result_type(a, b)],\n+    )\n+    c = c.transpose(*all_dims, missing_dims=\"ignore\")\n+\n+    return c\n+\n+\n def dot(*arrays, dims=None, **kwargs):\n     \"\"\"Generalized dot product for xarray objects. Like np.einsum, but\n     provides a simpler interface based on array dimensions.\n",
  "test_patch": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1952,3 +1952,110 @@ def test_polyval(use_dask, use_datetime) -> None:\n     da_pv = xr.polyval(da.x, coeffs)\n \n     xr.testing.assert_allclose(da, da_pv.T)\n+\n+\n+@pytest.mark.parametrize(\"use_dask\", [False, True])\n+@pytest.mark.parametrize(\n+    \"a, b, ae, be, dim, axis\",\n+    [\n+        [\n+            xr.DataArray([1, 2, 3]),\n+            xr.DataArray([4, 5, 6]),\n+            [1, 2, 3],\n+            [4, 5, 6],\n+            \"dim_0\",\n+            -1,\n+        ],\n+        [\n+            xr.DataArray([1, 2]),\n+            xr.DataArray([4, 5, 6]),\n+            [1, 2],\n+            [4, 5, 6],\n+            \"dim_0\",\n+            -1,\n+        ],\n+        [\n+            xr.Variable(dims=[\"dim_0\"], data=[1, 2, 3]),\n+            xr.Variable(dims=[\"dim_0\"], data=[4, 5, 6]),\n+            [1, 2, 3],\n+            [4, 5, 6],\n+            \"dim_0\",\n+            -1,\n+        ],\n+        [\n+            xr.Variable(dims=[\"dim_0\"], data=[1, 2]),\n+            xr.Variable(dims=[\"dim_0\"], data=[4, 5, 6]),\n+            [1, 2],\n+            [4, 5, 6],\n+            \"dim_0\",\n+            -1,\n+        ],\n+        [  # Test dim in the middle:\n+            xr.DataArray(\n+                np.arange(0, 5 * 3 * 4).reshape((5, 3, 4)),\n+                dims=[\"time\", \"cartesian\", \"var\"],\n+                coords=dict(\n+                    time=([\"time\"], np.arange(0, 5)),\n+                    cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"]),\n+                    var=([\"var\"], [1, 1.5, 2, 2.5]),\n+                ),\n+            ),\n+            xr.DataArray(\n+                np.arange(0, 5 * 3 * 4).reshape((5, 3, 4)) + 1,\n+                dims=[\"time\", \"cartesian\", \"var\"],\n+                coords=dict(\n+                    time=([\"time\"], np.arange(0, 5)),\n+                    cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"]),\n+                    var=([\"var\"], [1, 1.5, 2, 2.5]),\n+                ),\n+            ),\n+            np.arange(0, 5 * 3 * 4).reshape((5, 3, 4)),\n+            np.arange(0, 5 * 3 * 4).reshape((5, 3, 4)) + 1,\n+            \"cartesian\",\n+            1,\n+        ],\n+        [  # Test 1 sized arrays with coords:\n+            xr.DataArray(\n+                np.array([1]),\n+                dims=[\"cartesian\"],\n+                coords=dict(cartesian=([\"cartesian\"], [\"z\"])),\n+            ),\n+            xr.DataArray(\n+                np.array([4, 5, 6]),\n+                dims=[\"cartesian\"],\n+                coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"])),\n+            ),\n+            [0, 0, 1],\n+            [4, 5, 6],\n+            \"cartesian\",\n+            -1,\n+        ],\n+        [  # Test filling inbetween with coords:\n+            xr.DataArray(\n+                [1, 2],\n+                dims=[\"cartesian\"],\n+                coords=dict(cartesian=([\"cartesian\"], [\"x\", \"z\"])),\n+            ),\n+            xr.DataArray(\n+                [4, 5, 6],\n+                dims=[\"cartesian\"],\n+                coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"])),\n+            ),\n+            [1, 0, 2],\n+            [4, 5, 6],\n+            \"cartesian\",\n+            -1,\n+        ],\n+    ],\n+)\n+def test_cross(a, b, ae, be, dim: str, axis: int, use_dask: bool) -> None:\n+    expected = np.cross(ae, be, axis=axis)\n+\n+    if use_dask:\n+        if not has_dask:\n+            pytest.skip(\"test for dask.\")\n+        a = a.chunk()\n+        b = b.chunk()\n+\n+    actual = xr.cross(a, b, dim=dim)\n+    xr.testing.assert_duckarray_allclose(expected, actual)\n",
  "problem_statement": "Feature request: vector cross product\nxarray currently has the `xarray.dot()` function for calculating arbitrary dot products which is indeed very handy.\r\nSometimes, especially for physical applications I also need a vector cross product. I' wondering whether you would be interested in having ` xarray.cross` as a wrapper of [`numpy.cross`.](https://docs.scipy.org/doc/numpy/reference/generated/numpy.cross.html) I currently use the following implementation:\r\n\r\n```python\r\ndef cross(a, b, spatial_dim, output_dtype=None):\r\n    \"\"\"xarray-compatible cross product\r\n    \r\n    Compatible with dask, parallelization uses a.dtype as output_dtype\r\n    \"\"\"\r\n    # TODO find spatial dim default by looking for unique 3(or 2)-valued dim?\r\n    for d in (a, b):\r\n        if spatial_dim not in d.dims:\r\n            raise ValueError('dimension {} not in {}'.format(spatial_dim, d))\r\n        if d.sizes[spatial_dim] != 3:  #TODO handle 2-valued cases\r\n            raise ValueError('dimension {} has not length 3 in {}'.format(d))\r\n        \r\n    if output_dtype is None: \r\n        output_dtype = a.dtype  # TODO some better way to determine default?\r\n    c = xr.apply_ufunc(np.cross, a, b,\r\n                       input_core_dims=[[spatial_dim], [spatial_dim]], \r\n                       output_core_dims=[[spatial_dim]], \r\n                       dask='parallelized', output_dtypes=[output_dtype]\r\n                      )\r\n    return c\r\n\r\n```\r\n\r\n#### Example usage\r\n\r\n```python\r\nimport numpy as np\r\nimport xarray as xr\r\na = xr.DataArray(np.empty((10, 3)), dims=['line', 'cartesian'])\r\nb = xr.full_like(a, 1)\r\nc = cross(a, b, 'cartesian')\r\n```\r\n\r\n#### Main question\r\nDo you want such a function (and possibly associated `DataArray.cross` methods) in the `xarray` namespace, or should it be in some other package?  I didn't find a package which would be a good fit as this is close to core numpy functionality and isn't as domain specific as some geo packages. I'm not aware of some \"xrphysics\" package.\r\n\r\nI could make a PR if you'd want to have it in `xarray` directly.\r\n\r\n#### Output of ``xr.show_versions()``\r\n<details>\r\n# Paste the output here xr.show_versions() here\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit: None\r\npython: 3.7.3 (default, Mar 27 2019, 22:11:17) \r\n[GCC 7.3.0]\r\npython-bits: 64\r\nOS: Linux\r\nOS-release: 4.9.0-9-amd64\r\nmachine: x86_64\r\nprocessor: \r\nbyteorder: little\r\nLC_ALL: None\r\nLANG: en_US.UTF-8\r\nLOCALE: en_US.UTF-8\r\nlibhdf5: 1.10.4\r\nlibnetcdf: 4.6.1\r\n\r\nxarray: 0.12.3\r\npandas: 0.24.2\r\nnumpy: 1.16.4\r\nscipy: 1.3.0\r\nnetCDF4: 1.4.2\r\npydap: None\r\nh5netcdf: 0.7.4\r\nh5py: 2.9.0\r\nNio: None\r\nzarr: None\r\ncftime: 1.0.3.4\r\nnc_time_axis: None\r\nPseudoNetCDF: None\r\nrasterio: None\r\ncfgrib: None\r\niris: None\r\nbottleneck: 1.2.1\r\ndask: 2.1.0\r\ndistributed: 2.1.0\r\nmatplotlib: 3.1.0\r\ncartopy: None\r\nseaborn: 0.9.0\r\nnumbagg: None\r\nsetuptools: 41.0.1\r\npip: 19.1.1\r\nconda: 4.7.11\r\npytest: 5.0.1\r\nIPython: 7.6.1\r\nsphinx: 2.1.2\r\n</details>\r\n\n",
  "hints_text": "Very useful :+1: \r\nI would add:\r\n```\r\n    try:\r\n        c.attrs[\"units\"] = a.attrs[\"units\"] + '*' + b.attrs[\"units\"]\r\n    except KeyError:\r\n        pass\r\n```\r\nto preserve units - but I am not sure that is in scope for xarray.\nit is not, but we have been working on [unit aware arrays with `pint`](https://github.com/pydata/xarray/issues/3594). Once that is done, unit propagation should work automatically.",
  "created_at": "2021-05-23T13:03:42Z",
  "version": "0.18",
  "FAIL_TO_PASS": "[\"xarray/tests/test_computation.py::test_cross[a0-b0-ae0-be0-dim_0--1-False]\", \"xarray/tests/test_computation.py::test_cross[a1-b1-ae1-be1-dim_0--1-False]\", \"xarray/tests/test_computation.py::test_cross[a2-b2-ae2-be2-dim_0--1-False]\", \"xarray/tests/test_computation.py::test_cross[a3-b3-ae3-be3-dim_0--1-False]\", \"xarray/tests/test_computation.py::test_cross[a4-b4-ae4-be4-cartesian-1-False]\", \"xarray/tests/test_computation.py::test_cross[a5-b5-ae5-be5-cartesian--1-False]\", \"xarray/tests/test_computation.py::test_cross[a6-b6-ae6-be6-cartesian--1-False]\"]",
  "PASS_TO_PASS": "[\"xarray/tests/test_computation.py::test_apply_exclude\", \"xarray/tests/test_computation.py::test_autocov[None-da_a0]\", \"xarray/tests/test_computation.py::test_autocov[None-da_a1]\", \"xarray/tests/test_computation.py::test_autocov[None-da_a2]\", \"xarray/tests/test_computation.py::test_autocov[None-da_a3]\", \"xarray/tests/test_computation.py::test_autocov[None-da_a4]\", \"xarray/tests/test_computation.py::test_autocov[dim3-da_a0]\", \"xarray/tests/test_computation.py::test_autocov[dim3-da_a1]\", \"xarray/tests/test_computation.py::test_autocov[dim3-da_a2]\", \"xarray/tests/test_computation.py::test_autocov[dim3-da_a3]\", \"xarray/tests/test_computation.py::test_autocov[dim3-da_a4]\", \"xarray/tests/test_computation.py::test_autocov[time-da_a0]\", \"xarray/tests/test_computation.py::test_autocov[time-da_a1]\", \"xarray/tests/test_computation.py::test_autocov[time-da_a2]\", \"xarray/tests/test_computation.py::test_autocov[time-da_a3]\", \"xarray/tests/test_computation.py::test_autocov[time-da_a4]\", \"xarray/tests/test_computation.py::test_autocov[x-da_a0]\", \"xarray/tests/test_computation.py::test_autocov[x-da_a1]\", \"xarray/tests/test_computation.py::test_autocov[x-da_a2]\", \"xarray/tests/test_computation.py::test_autocov[x-da_a3]\", \"xarray/tests/test_computation.py::test_autocov[x-da_a4]\", \"xarray/tests/test_computation.py::test_broadcast_compat_data_1d\", \"xarray/tests/test_computation.py::test_broadcast_compat_data_2d\", \"xarray/tests/test_computation.py::test_collect_dict_values\", \"xarray/tests/test_computation.py::test_corr[None-da_a0-da_b0]\", \"xarray/tests/test_computation.py::test_corr[None-da_a1-da_b1]\", \"xarray/tests/test_computation.py::test_corr[None-da_a2-da_b2]\", \"xarray/tests/test_computation.py::test_corr[time-da_a0-da_b0]\", \"xarray/tests/test_computation.py::test_corr[time-da_a1-da_b1]\", \"xarray/tests/test_computation.py::test_corr[time-da_a2-da_b2]\", \"xarray/tests/test_computation.py::test_corr_only_dataarray\", \"xarray/tests/test_computation.py::test_cov[None-da_a0-da_b0-0]\", \"xarray/tests/test_computation.py::test_cov[None-da_a0-da_b0-1]\", \"xarray/tests/test_computation.py::test_cov[None-da_a1-da_b1-0]\", \"xarray/tests/test_computation.py::test_cov[None-da_a1-da_b1-1]\", \"xarray/tests/test_computation.py::test_cov[None-da_a2-da_b2-0]\", \"xarray/tests/test_computation.py::test_cov[None-da_a2-da_b2-1]\", \"xarray/tests/test_computation.py::test_cov[time-da_a0-da_b0-0]\", \"xarray/tests/test_computation.py::test_cov[time-da_a0-da_b0-1]\", \"xarray/tests/test_computation.py::test_cov[time-da_a1-da_b1-0]\", \"xarray/tests/test_computation.py::test_cov[time-da_a1-da_b1-1]\", \"xarray/tests/test_computation.py::test_cov[time-da_a2-da_b2-0]\", \"xarray/tests/test_computation.py::test_cov[time-da_a2-da_b2-1]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a0-da_b0]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a1-da_b1]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a2-da_b2]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a3-da_b3]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a4-da_b4]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a5-da_b5]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a6-da_b6]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a7-da_b7]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[None-da_a8-da_b8]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a0-da_b0]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a1-da_b1]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a2-da_b2]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a3-da_b3]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a4-da_b4]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a5-da_b5]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a6-da_b6]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a7-da_b7]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[time-da_a8-da_b8]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a0-da_b0]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a1-da_b1]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a2-da_b2]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a3-da_b3]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a4-da_b4]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a5-da_b5]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a6-da_b6]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a7-da_b7]\", \"xarray/tests/test_computation.py::test_covcorr_consistency[x-da_a8-da_b8]\", \"xarray/tests/test_computation.py::test_dataset_join\", \"xarray/tests/test_computation.py::test_dot[False]\", \"xarray/tests/test_computation.py::test_dot_align_coords[False]\", \"xarray/tests/test_computation.py::test_join_dict_keys\", \"xarray/tests/test_computation.py::test_keep_attrs\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[False]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[True]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[default]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[drop]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[drop_conflicts]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[no_conflicts]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray[override]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[False-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[False-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[True-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[True-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[default-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[default-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[drop-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[drop-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[drop_conflicts-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[drop_conflicts-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[no_conflicts-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[no_conflicts-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[override-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataarray_variables[override-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[False]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[True]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[default]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[drop]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[drop_conflicts]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[no_conflicts]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset[override]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[False-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[False-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[False-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[True-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[True-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[True-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[default-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[default-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[default-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[drop-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[drop-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[drop-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[drop_conflicts-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[drop_conflicts-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[drop_conflicts-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[no_conflicts-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[no_conflicts-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[no_conflicts-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[override-coord]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[override-data]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_dataset_variables[override-dim]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[False]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[True]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[default]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[drop]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[drop_conflicts]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[no_conflicts]\", \"xarray/tests/test_computation.py::test_keep_attrs_strategies_variable[override]\", \"xarray/tests/test_computation.py::test_ordered_set_intersection\", \"xarray/tests/test_computation.py::test_ordered_set_union\", \"xarray/tests/test_computation.py::test_output_wrong_dim_size\", \"xarray/tests/test_computation.py::test_output_wrong_dims\", \"xarray/tests/test_computation.py::test_output_wrong_number\", \"xarray/tests/test_computation.py::test_polyval[False-False]\", \"xarray/tests/test_computation.py::test_result_name\", \"xarray/tests/test_computation.py::test_signature_properties\", \"xarray/tests/test_computation.py::test_unified_dim_sizes\", \"xarray/tests/test_computation.py::test_vectorize\", \"xarray/tests/test_computation.py::test_vectorize_exclude_dims\", \"xarray/tests/test_computation.py::test_where\"]",
  "environment_setup_commit": "4f1e2d37b662079e830c9672400fabc19b44a376",
  "patch_files": [
    "xarray/__init__.py",
    "xarray/core/computation.py"
  ],
  "test_patch_files": [
    "xarray/tests/test_computation.py"
  ],
  "patch_diff_details": {
    "xarray/__init__.py": {
      "diffs": [
        {
          "start_line_old": 19,
          "end_line_old": 19,
          "file_pos": 4,
          "file_context_length": 61173,
          "pos": 4,
          "context_length": 2528
        },
        {
          "start_line_old": 63,
          "end_line_old": 63,
          "file_pos": 4,
          "file_context_length": 61173,
          "pos": 4,
          "context_length": 2528
        }
      ]
    },
    "xarray/core/computation.py": {
      "diffs": [
        {
          "start_line_old": 39,
          "end_line_old": 39,
          "file_pos": 1,
          "file_context_length": 14806,
          "closest_snippet_id": "/tmp/repos/xarray/xarray/core/computation.py_dot.4_dot.31.1",
          "closest_snippet_line_distance": 1417
        },
        {
          "start_line_old": 1376,
          "end_line_old": 1376,
          "file_pos": 1,
          "file_context_length": 14806,
          "pos": 1,
          "context_length": 718
        }
      ]
    }
  },
  "vectors": 1224,
  "snippets": [
    {
      "position": 1,
      "id": "/tmp/repos/xarray/xarray/core/computation.py_dot_dot.Variable",
      "distance": 0.7981324195861816,
      "file_path": "xarray/core/computation.py",
      "start_line": 1376,
      "end_line": 1454,
      "tokens": 718,
      "context_length": 718,
      "file_pos": 1
    },
    {
      "position": 2,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray.real_DataArray.dot.4.1",
      "distance": 0.8311179280281067,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 3301,
      "end_line": 3359,
      "tokens": 416,
      "context_length": 1134
    },
    {
      "position": 3,
      "id": "/tmp/repos/xarray/xarray/core/duck_array_ops.py_1_around.__doc___39.1",
      "distance": 0.8495632410049438,
      "file_path": "xarray/core/duck_array_ops.py",
      "start_line": 1,
      "end_line": 93,
      "tokens": 727,
      "context_length": 1861
    },
    {
      "position": 4,
      "id": "/tmp/repos/xarray/xarray/__init__.py_ufuncs_",
      "distance": 0.8560857772827148,
      "file_path": "xarray/__init__.py",
      "start_line": 1,
      "end_line": 100,
      "tokens": 667,
      "context_length": 2528,
      "file_pos": 4
    },
    {
      "position": 5,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_1_25.T_Xarray",
      "distance": 0.8730664253234863,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 1,
      "end_line": 89,
      "tokens": 465,
      "context_length": 2993
    },
    {
      "position": 6,
      "id": "/tmp/repos/xarray/xarray/core/computation.py_dot.4_dot.31.1",
      "distance": 0.8807938098907471,
      "file_path": "xarray/core/computation.py",
      "start_line": 1456,
      "end_line": 1518,
      "tokens": 601,
      "context_length": 3594,
      "file_pos": 4
    },
    {
      "position": 7,
      "id": "/tmp/repos/xarray/xarray/core/dataset.py_copy__DATETIMEINDEX_COMPONENTS.1",
      "distance": 0.8822554349899292,
      "file_path": "xarray/core/dataset.py",
      "start_line": 1,
      "end_line": 135,
      "tokens": 661,
      "context_length": 4255
    },
    {
      "position": 8,
      "id": "/tmp/repos/xarray/xarray/ufuncs.py_1__dispatch_priority.2.1",
      "distance": 0.8965915441513062,
      "file_path": "xarray/ufuncs.py",
      "start_line": 1,
      "end_line": 36,
      "tokens": 239,
      "context_length": 4494
    },
    {
      "position": 9,
      "id": "/tmp/repos/xarray/xarray/core/types.py_1_",
      "distance": 0.9066620469093323,
      "file_path": "xarray/core/types.py",
      "start_line": 1,
      "end_line": 34,
      "tokens": 297,
      "context_length": 4791
    },
    {
      "position": 10,
      "id": "/tmp/repos/xarray/xarray/core/dask_array_compat.py_9_",
      "distance": 0.9129012227058411,
      "file_path": "xarray/core/dask_array_compat.py",
      "start_line": 117,
      "end_line": 187,
      "tokens": 652,
      "context_length": 5443
    },
    {
      "position": 11,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/interp.py_np_new_y_long.1",
      "distance": 0.9191265106201172,
      "file_path": "asv_bench/benchmarks/interp.py",
      "start_line": 1,
      "end_line": 18,
      "tokens": 150,
      "context_length": 5593
    },
    {
      "position": 12,
      "id": "/tmp/repos/xarray/xarray/core/common.py_1_T.1",
      "distance": 0.9230623245239258,
      "file_path": "xarray/core/common.py",
      "start_line": 1,
      "end_line": 52,
      "tokens": 258,
      "context_length": 5851
    },
    {
      "position": 13,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/indexing.py_os_vectorized_assignment_values.1",
      "distance": 0.9292086362838745,
      "file_path": "asv_bench/benchmarks/indexing.py",
      "start_line": 1,
      "end_line": 59,
      "tokens": 738,
      "context_length": 6589
    },
    {
      "position": 14,
      "id": "/tmp/repos/xarray/xarray/core/arithmetic.py_SupportsArithmetic.__array_ufunc___SupportsArithmetic.__array_ufunc__.9.1",
      "distance": 0.9316316843032837,
      "file_path": "xarray/core/arithmetic.py",
      "start_line": 41,
      "end_line": 90,
      "tokens": 458,
      "context_length": 7047
    },
    {
      "position": 15,
      "id": "/tmp/repos/xarray/xarray/core/npcompat.py_sys_31.2.2.17",
      "distance": 0.9329760670661926,
      "file_path": "xarray/core/npcompat.py",
      "start_line": 31,
      "end_line": 79,
      "tokens": 390,
      "context_length": 7437
    },
    {
      "position": 16,
      "id": "/tmp/repos/xarray/xarray/core/pycompat.py_is_dask_collection_",
      "distance": 0.9376343488693237,
      "file_path": "xarray/core/pycompat.py",
      "start_line": 46,
      "end_line": 68,
      "tokens": 129,
      "context_length": 7566
    },
    {
      "position": 17,
      "id": "/tmp/repos/xarray/xarray/core/parallel.py_1_assert_chunks_compatible.3.1.1",
      "distance": 0.9423326849937439,
      "file_path": "xarray/core/parallel.py",
      "start_line": 1,
      "end_line": 52,
      "tokens": 239,
      "context_length": 7805
    },
    {
      "position": 18,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/rolling.py_np_randn_long.1",
      "distance": 0.9518110752105713,
      "file_path": "asv_bench/benchmarks/rolling.py",
      "start_line": 1,
      "end_line": 17,
      "tokens": 113,
      "context_length": 7918
    },
    {
      "position": 19,
      "id": "/tmp/repos/xarray/xarray/core/duck_array_ops.py_mean.numeric_only_",
      "distance": 0.9536538124084473,
      "file_path": "xarray/core/duck_array_ops.py",
      "start_line": 578,
      "end_line": 654,
      "tokens": 620,
      "context_length": 8538
    },
    {
      "position": 20,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray_DataArray.1",
      "distance": 0.9552634358406067,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 218,
      "end_line": 340,
      "tokens": 1282,
      "context_length": 9820
    },
    {
      "position": 21,
      "id": "/tmp/repos/xarray/xarray/plot/utils.py_itertools__determine_extend.3.4.1.1",
      "distance": 0.9610038995742798,
      "file_path": "xarray/plot/utils.py",
      "start_line": 1,
      "end_line": 66,
      "tokens": 321,
      "context_length": 10141
    },
    {
      "position": 22,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray._binary_op_DataArray._binary_op.8.1",
      "distance": 0.9657825827598572,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 3071,
      "end_line": 3093,
      "tokens": 188,
      "context_length": 10329
    },
    {
      "position": 23,
      "id": "/tmp/repos/xarray/xarray/core/indexing.py_enum_maybe_cast_to_coords_dtype",
      "distance": 0.9711795449256897,
      "file_path": "xarray/core/indexing.py",
      "start_line": 1,
      "end_line": 22,
      "tokens": 124,
      "context_length": 10453
    },
    {
      "position": 24,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray.interp_DataArray.interp.4.1",
      "distance": 0.9718632698059082,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 1621,
      "end_line": 1749,
      "tokens": 1358,
      "context_length": 11811
    },
    {
      "position": 25,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray.sel_DataArray.sel.3.1",
      "distance": 0.9728202819824219,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 1223,
      "end_line": 1339,
      "tokens": 1181,
      "context_length": 12992
    },
    {
      "position": 26,
      "id": "/tmp/repos/xarray/xarray/testing.py_assert_allclose_assert_allclose.7.5.1",
      "distance": 0.9728778600692749,
      "file_path": "xarray/testing.py",
      "start_line": 119,
      "end_line": 173,
      "tokens": 490,
      "context_length": 13482
    },
    {
      "position": 27,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/reindexing.py_np_",
      "distance": 0.9729569554328918,
      "file_path": "asv_bench/benchmarks/reindexing.py",
      "start_line": 1,
      "end_line": 53,
      "tokens": 415,
      "context_length": 13897
    },
    {
      "position": 28,
      "id": "/tmp/repos/xarray/xarray/core/missing.py_dt_broadcast_variables",
      "distance": 0.9794872403144836,
      "file_path": "xarray/core/missing.py",
      "start_line": 1,
      "end_line": 18,
      "tokens": 139,
      "context_length": 14036
    },
    {
      "position": 29,
      "id": "/tmp/repos/xarray/xarray/core/pycompat.py_1_DuckArrayModule.__init__.self.available.1",
      "distance": 0.9803412556648254,
      "file_path": "xarray/core/pycompat.py",
      "start_line": 1,
      "end_line": 43,
      "tokens": 288,
      "context_length": 14324
    },
    {
      "position": 30,
      "id": "/tmp/repos/xarray/xarray/core/arithmetic.py_VariableArithmetic_",
      "distance": 0.9818474054336548,
      "file_path": "xarray/core/arithmetic.py",
      "start_line": 93,
      "end_line": 146,
      "tokens": 258,
      "context_length": 14582
    },
    {
      "position": 31,
      "id": "/tmp/repos/xarray/xarray/core/alignment.py_align.1_align.1",
      "distance": 0.984109103679657,
      "file_path": "xarray/core/alignment.py",
      "start_line": 85,
      "end_line": 272,
      "tokens": 1943,
      "context_length": 16525
    },
    {
      "position": 32,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray.__delitem___DataArray.coords.2.1",
      "distance": 0.9844862222671509,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 764,
      "end_line": 836,
      "tokens": 574,
      "context_length": 17099
    },
    {
      "position": 33,
      "id": "/tmp/repos/xarray/asv_bench/benchmarks/pandas.py_np_",
      "distance": 0.9866517186164856,
      "file_path": "asv_bench/benchmarks/pandas.py",
      "start_line": 1,
      "end_line": 27,
      "tokens": 167,
      "context_length": 17266
    },
    {
      "position": 34,
      "id": "/tmp/repos/xarray/xarray/core/missing.py_interp_func.4_interp_func.5.1",
      "distance": 0.9887933731079102,
      "file_path": "xarray/core/missing.py",
      "start_line": 699,
      "end_line": 766,
      "tokens": 568,
      "context_length": 17834
    },
    {
      "position": 35,
      "id": "/tmp/repos/xarray/xarray/core/dataarray.py_DataArray.pad.1_DataArray.pad.3.1",
      "distance": 0.9904286861419678,
      "file_path": "xarray/core/dataarray.py",
      "start_line": 3928,
      "end_line": 4078,
      "tokens": 1787,
      "context_length": 19621
    },
    {
      "position": 36,
      "id": "/tmp/repos/xarray/xarray/core/_typed_ops.py_DataArrayOpsMixin.__iand___DataArrayOpsMixin.conjugate.__doc__.1",
      "distance": 0.9916363954544067,
      "file_path": "xarray/core/_typed_ops.py",
      "start_line": 307,
      "end_line": 386,
      "tokens": 879,
      "context_length": 20500
    }
  ],
  "files": [
    {
      "file_path": "xarray/core/computation.py",
      "position": 1,
      "tokens": 14806,
      "context_length": 14806
    },
    {
      "file_path": "xarray/core/dataarray.py",
      "position": 2,
      "tokens": 40117,
      "context_length": 54923
    },
    {
      "file_path": "xarray/core/duck_array_ops.py",
      "position": 3,
      "tokens": 5583,
      "context_length": 60506
    },
    {
      "file_path": "xarray/__init__.py",
      "position": 4,
      "tokens": 667,
      "context_length": 61173
    },
    {
      "file_path": "xarray/core/dataset.py",
      "position": 5,
      "tokens": 65629,
      "context_length": 126802
    },
    {
      "file_path": "xarray/ufuncs.py",
      "position": 6,
      "tokens": 1217,
      "context_length": 128019
    },
    {
      "file_path": "xarray/core/types.py",
      "position": 7,
      "tokens": 297,
      "context_length": 128316
    },
    {
      "file_path": "xarray/core/dask_array_compat.py",
      "position": 8,
      "tokens": 1537,
      "context_length": 129853
    },
    {
      "file_path": "asv_bench/benchmarks/interp.py",
      "position": 9,
      "tokens": 451,
      "context_length": 130304
    },
    {
      "file_path": "xarray/core/common.py",
      "position": 10,
      "tokens": 15887,
      "context_length": 146191
    },
    {
      "file_path": "asv_bench/benchmarks/indexing.py",
      "position": 11,
      "tokens": 1501,
      "context_length": 147692
    },
    {
      "file_path": "xarray/core/arithmetic.py",
      "position": 12,
      "tokens": 959,
      "context_length": 148651
    },
    {
      "file_path": "xarray/core/npcompat.py",
      "position": 13,
      "tokens": 1638,
      "context_length": 150289
    },
    {
      "file_path": "xarray/core/pycompat.py",
      "position": 14,
      "tokens": 419,
      "context_length": 150708
    },
    {
      "file_path": "xarray/core/parallel.py",
      "position": 15,
      "tokens": 5128,
      "context_length": 155836
    },
    {
      "file_path": "asv_bench/benchmarks/rolling.py",
      "position": 16,
      "tokens": 1275,
      "context_length": 157111
    },
    {
      "file_path": "xarray/plot/utils.py",
      "position": 17,
      "tokens": 9243,
      "context_length": 166354
    },
    {
      "file_path": "xarray/core/indexing.py",
      "position": 18,
      "tokens": 11312,
      "context_length": 177666
    },
    {
      "file_path": "xarray/testing.py",
      "position": 19,
      "tokens": 3089,
      "context_length": 180755
    },
    {
      "file_path": "asv_bench/benchmarks/reindexing.py",
      "position": 20,
      "tokens": 415,
      "context_length": 181170
    },
    {
      "file_path": "xarray/core/missing.py",
      "position": 21,
      "tokens": 6211,
      "context_length": 187381
    },
    {
      "file_path": "xarray/core/alignment.py",
      "position": 22,
      "tokens": 6269,
      "context_length": 193650
    },
    {
      "file_path": "asv_bench/benchmarks/pandas.py",
      "position": 23,
      "tokens": 167,
      "context_length": 193817
    },
    {
      "file_path": "xarray/core/_typed_ops.py",
      "position": 24,
      "tokens": 7074,
      "context_length": 200891
    }
  ]
}