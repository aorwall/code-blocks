# sympy__sympy-12307

| **sympy/sympy** | `c9c6b85407a5d2b1bd5ee750e66b03c75ff35271` |
| ---- | ---- |
| **No of patches** | 1 |
| **All found context length** | - |
| **Any found context length** | - |
| **Avg pos** | - |
| **Min pos** | - |
| **Max pos** | - |
| **Top file pos** | 4 |
| **Missing snippets** | 1 |
| **Missing patch files** | 0 |


## Expected patch

```diff
diff --git a/sympy/printing/fcode.py b/sympy/printing/fcode.py
--- a/sympy/printing/fcode.py
+++ b/sympy/printing/fcode.py
@@ -106,6 +106,14 @@ def _get_statement(self, codestring):
 
     def _get_comment(self, text):
         return "! {0}".format(text)
+#issue 12267
+    def _print_sign(self,func):
+        if func.args[0].is_integer:
+            return "merge(0, isign(1, {0}), {0} == 0)".format(self._print(func.args[0]))
+        elif func.args[0].is_complex:
+            return "merge(cmplx(0d0, 0d0), {0}/abs({0}), abs({0}) == 0d0)".format(self._print(func.args[0]))
+        else:
+            return "merge(0d0, dsign(1d0, {0}), {0} == 0d0)".format(self._print(func.args[0]))
 
     def _declare_number_const(self, name, value):
         return "parameter ({0} = {1})".format(name, value)

```

## Expected file changes

| File | Start line | End line | Found on position | Found file position | Context length |
| ---- | ---------- | -------- | ----------------- | ------------------- | -------------- |
| sympy/printing/fcode.py | 109 | 109 | - | 4 | -


## Problem Statement

```
Codegen: sign function in Fortran
The Fortran code generated by Sympy for the sign function is not a valid Fortran syntax.

With Sympy 1.0 and Python 3.6:
\`\`\`python
In [1]: import sympy as sp

In [2]: from sympy.abc import x

In [3]: sp.fcode(sp.sign(x))
Out[3]: '      sign(x)'
\`\`\`
(The same behavior is obtained with `sympy.utilities.codegen`.)

The syntax of the sign function in Fortran is given [here](https://gcc.gnu.org/onlinedocs/gfortran/SIGN.html).

I guess it would be preferable to generate something like `sign(1, x)` or `sign(1d0, x)` depending of the context. I'm not sure how to get the same behavior than Sympy for `x=0`, but at least it would be compilable.

```

## Retrieved code snippets

| Position | File | Start line | End line | Tokens | Sum tokens | File tokens |
| -------- | ---- | ---------- | -------- | ------ | ---------- | ----------- |
| 1 | 1 sympy/series/gruntz.py | 352 | 406| 400 | 400 | 6249 | 
| 2 | 2 sympy/functions/elementary/complexes.py | 319 | 334| 168 | 568 | 15146 | 
| 3 | 3 sympy/simplify/simplify.py | 322 | 381| 502 | 1070 | 26834 | 
| 4 | 3 sympy/functions/elementary/complexes.py | 219 | 270| 313 | 1383 | 26834 | 
| 5 | 3 sympy/functions/elementary/complexes.py | 272 | 317| 380 | 1763 | 26834 | 
| 6 | **4 sympy/printing/fcode.py** | 1 | 49| 361 | 2124 | 31539 | 
| 7 | 5 sympy/core/exprtools.py | 102 | 203| 906 | 3030 | 43446 | 
| 8 | 5 sympy/functions/elementary/complexes.py | 336 | 375| 287 | 3317 | 43446 | 
| 9 | 6 sympy/functions/special/delta_functions.py | 535 | 575| 336 | 3653 | 48469 | 
| 10 | 7 sympy/polys/subresultants_qq_zz.py | 283 | 336| 420 | 4073 | 72092 | 
| 11 | 8 sympy/simplify/fu.py | 1965 | 2019| 519 | 4592 | 90380 | 
| 12 | 9 sympy/tensor/tensor.py | 607 | 625| 166 | 4758 | 124441 | 
| 13 | 10 sympy/core/expr.py | 186 | 227| 554 | 5312 | 152404 | 
| 14 | 11 sympy/functions/special/error_functions.py | 1277 | 1290| 170 | 5482 | 172437 | 
| 15 | 12 sympy/core/numbers.py | 3654 | 3704| 307 | 5789 | 199897 | 


### Hint

```
The x=0 case probably matters, because SymPy could return an expression that uses `sign` assuming that meaning. Does Fortran have ternary expressions? 
Looks like fortran does support ternary expressions though `merge`:
https://en.wikipedia.org/wiki/%3F:#Fortran
@bjodah 
I would like to work in this issue. Could you please help me out?
Is the following code correct?
`sp.sign(x) = merge(0, sp.sign(x), x is 0)`
@mamakancha no not quite. Fortran knows nothing about `sp.`. You can look at the C version:
\`\`\`
$ grep -A1 --include "*.py" _print_sign -R sympy/
\`\`\`
@**bjodah** I think the changes should be done in `doprint()` of codeprinter.py but not quite sure where and what the code should be 
@SatyaPrakashDwibedi I don't think that's needed. Simply adding a method to the printer class for fortran code should be enough (in analogy with the `_print_sign` method in the `CCodePrinter` class).
With a recent version a `gfortran`, I can confirm that
\`\`\`fortran
merge(0, sign(1, x), x == 0)
\`\`\`
\`\`\`fortran
merge(0e0, sign(1e0, x), x == 0e0)
\`\`\`
and
\`\`\`fortran
merge(0d0, sign(1d0, x), x == 0d0)
\`\`\`
work as expected, for respectively integer, real and double precision `x`.

Note that [`merge`](https://gcc.gnu.org/onlinedocs/gfortran/MERGE.html) is only defined for Fortran 95 standard (or later). Another solution might be needed for the legacy Fortran 77 standard.
Yes, I noticed that `merge` is a rather "new" addition. I don't know of an easy fix for fortran 77, there I think one would have to implement it using if statements. But supporting "only" F95+ is still a step in the right direction.
@bjodah will this work?
`>>> def p(func):
...   if func.args[0].is_positive:
...     return '(SIGN(1,{0})'.format((func.args[0]))
...   elif func.args[0].is_negative:
...     return '(SIGN(-1,{0})'.format((func.args[0]))
...   else:
...     return '(SIGN(0,{0})'.format((func.args[0]))
...`
@SatyaPrakashDwibedi no that will not work. The argument might be symbolic and its sign is not known prior to runtime (or we would obviously not need to generate any call at all). You should look at `test_fcode.py` and write a test for sign checking that generated code looks like @Franjov suggested, then run `./bin/test sympy/printing/tests/test_fcode.py` and watch it fail. Then edit `sympy/printing/fcode.py` to give the code printer a printing method analogous to the one in `ccode.py`. If done right the test should now pass. You should then verify that generated code actually compiles using e.g. `gfortran`. Then just commit and push and open a PR.
@bjodah Will this work for test_fcode.py
`def test_sign():`
    ` x=symbols('x',Integer=True)`
 `    y=symbols('y',real=True)`
 `    z=symbols('z',Double=True)`
 `    assert fcode(sign(x))=="      merge(0, sign(1, x), x == 0)"`
 `    assert fcode(sign(y))=="      merge(0e0, sign(1e0, x), x == 0e0)"`
 `    assert fcode(sign(z))=="      merge(0d0, sign(1d0, x), x == 0d0)" `
@SatyaPrakashDwibedi, that looks quite good, I'd suggest some minor changes:
\`\`\`
def test_sign():
    x=symbols('x')
    y=symbols('y', integer=True)
    assert fcode(sign(x), source_format='free') == "merge(0d0, dsign(1d0, x), x == 0d0)"
    assert fcode(sign(y), source_format='free') == "merge(0, isign(1, x), x == 0)"
\`\`\`
maybe we should handle more cases, but I don't write that much fortran so it's hard for me to be sure, @Franjov what do you think?
@bjodah Should I move to `fcode.py`
@bjodah I think there should be a check in `fcode.py` for type of variables to return right type of string , and how should I implement that.
You could also deal with the complex case. Something like
\`\`\`fortran
merge( cmplx(0d0, 0d0), z/abs(z), abs(z) == 0d0)
\`\`\`
(not tested in Fortran yet).

Actually, it is probably safer to code `x == 0d0` as something like `abs(x) < epsilon`.
But `epsilon` might be too dependent of the problem for a code generator without more context.
```

## Patch

```diff
diff --git a/sympy/printing/fcode.py b/sympy/printing/fcode.py
--- a/sympy/printing/fcode.py
+++ b/sympy/printing/fcode.py
@@ -106,6 +106,14 @@ def _get_statement(self, codestring):
 
     def _get_comment(self, text):
         return "! {0}".format(text)
+#issue 12267
+    def _print_sign(self,func):
+        if func.args[0].is_integer:
+            return "merge(0, isign(1, {0}), {0} == 0)".format(self._print(func.args[0]))
+        elif func.args[0].is_complex:
+            return "merge(cmplx(0d0, 0d0), {0}/abs({0}), abs({0}) == 0d0)".format(self._print(func.args[0]))
+        else:
+            return "merge(0d0, dsign(1d0, {0}), {0} == 0d0)".format(self._print(func.args[0]))
 
     def _declare_number_const(self, name, value):
         return "parameter ({0} = {1})".format(name, value)

```

## Test Patch

```diff
diff --git a/sympy/printing/tests/test_fcode.py b/sympy/printing/tests/test_fcode.py
--- a/sympy/printing/tests/test_fcode.py
+++ b/sympy/printing/tests/test_fcode.py
@@ -1,6 +1,6 @@
 from sympy import (sin, cos, atan2, log, exp, gamma, conjugate, sqrt,
     factorial, Integral, Piecewise, Add, diff, symbols, S, Float, Dummy, Eq,
-    Range, Catalan, EulerGamma, E, GoldenRatio, I, pi, Function, Rational, Integer, Lambda)
+    Range, Catalan, EulerGamma, E, GoldenRatio, I, pi, Function, Rational, Integer, Lambda, sign)
 
 from sympy.codegen import For, Assignment
 from sympy.core.relational import Relational
@@ -20,6 +20,14 @@ class nint(Function):
         def _fcode(self, printer):
             return "nint(%s)" % printer._print(self.args[0])
     assert fcode(nint(x)) == "      nint(x)"
+#issue 12267
+def test_fcode_sign():
+    x=symbols('x')
+    y=symbols('y', integer=True)
+    z=symbols('z', complex=True)
+    assert fcode(sign(x), source_format='free') == "merge(0d0, dsign(1d0, x), x == 0d0)"
+    assert fcode(sign(y), source_format='free') == "merge(0, isign(1, y), y == 0)"
+    assert fcode(sign(z), source_format='free') == "merge(cmplx(0d0, 0d0), z/abs(z), abs(z) == 0d0)"
 
 
 def test_fcode_Pow():

```


## Code snippets

### 1 - sympy/series/gruntz.py:

Start line: 352, End line: 406

```python
@debug
@cacheit
@timeit
def sign(e, x):
    """
    Returns a sign of an expression e(x) for x->oo.

    ::

        e >  0 for x sufficiently large ...  1
        e == 0 for x sufficiently large ...  0
        e <  0 for x sufficiently large ... -1

    The result of this function is currently undefined if e changes sign
    arbitarily often for arbitrarily large x (e.g. sin(x)).

    Note that this returns zero only if e is *constantly* zero
    for x sufficiently large. [If e is constant, of course, this is just
    the same thing as the sign of e.]
    """
    from sympy import sign as _sign
    if not isinstance(e, Basic):
        raise TypeError("e should be an instance of Basic")

    if e.is_positive:
        return 1
    elif e.is_negative:
        return -1
    elif e.is_zero:
        return 0

    elif not e.has(x):
        return _sign(e)
    elif e == x:
        return 1
    elif e.is_Mul:
        a, b = e.as_two_terms()
        sa = sign(a, x)
        if not sa:
            return 0
        return sa * sign(b, x)
    elif e.func is exp:
        return 1
    elif e.is_Pow:
        s = sign(e.base, x)
        if s == 1:
            return 1
        if e.exp.is_Integer:
            return s**e.exp
    elif e.func is log:
        return sign(e.args[0] - 1, x)

    # if all else fails, do it the hard way
    c0, e0 = mrv_leadterm(e, x)
    return sign(c0, x)
```
### 2 - sympy/functions/elementary/complexes.py:

Start line: 319, End line: 334

```python
class sign(Function):

    def _eval_Abs(self):
        if fuzzy_not(self.args[0].is_zero):
            return S.One

    def _eval_conjugate(self):
        return sign(conjugate(self.args[0]))

    def _eval_derivative(self, x):
        if self.args[0].is_real:
            from sympy.functions.special.delta_functions import DiracDelta
            return 2 * Derivative(self.args[0], x, evaluate=True) \
                * DiracDelta(self.args[0])
        elif self.args[0].is_imaginary:
            from sympy.functions.special.delta_functions import DiracDelta
            return 2 * Derivative(self.args[0], x, evaluate=True) \
                * DiracDelta(-S.ImaginaryUnit * self.args[0])
```
### 3 - sympy/simplify/simplify.py:

Start line: 322, End line: 381

```python
def signsimp(expr, evaluate=None):
    """Make all Add sub-expressions canonical wrt sign.

    If an Add subexpression, ``a``, can have a sign extracted,
    as determined by could_extract_minus_sign, it is replaced
    with Mul(-1, a, evaluate=False). This allows signs to be
    extracted from powers and products.

    Examples
    ========

    >>> from sympy import signsimp, exp, symbols
    >>> from sympy.abc import x, y
    >>> i = symbols('i', odd=True)
    >>> n = -1 + 1/x
    >>> n/x/(-n)**2 - 1/n/x
    (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
    >>> signsimp(_)
    0
    >>> x*n + x*-n
    x*(-1 + 1/x) + x*(1 - 1/x)
    >>> signsimp(_)
    0

    Since powers automatically handle leading signs

    >>> (-2)**i
    -2**i

    signsimp can be used to put the base of a power with an integer
    exponent into canonical form:

    >>> n**i
    (-1 + 1/x)**i

    By default, signsimp doesn't leave behind any hollow simplification:
    if making an Add canonical wrt sign didn't change the expression, the
    original Add is restored. If this is not desired then the keyword
    ``evaluate`` can be set to False:

    >>> e = exp(y - x)
    >>> signsimp(e) == e
    True
    >>> signsimp(e, evaluate=False)
    exp(-(x - y))

    """
    if evaluate is None:
        evaluate = global_evaluate[0]
    expr = sympify(expr)
    if not isinstance(expr, Expr) or expr.is_Atom:
        return expr
    e = sub_post(sub_pre(expr))
    if not isinstance(e, Expr) or e.is_Atom:
        return e
    if e.is_Add:
        return e.func(*[signsimp(a) for a in e.args])
    if evaluate:
        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
    return e
```
### 4 - sympy/functions/elementary/complexes.py:

Start line: 219, End line: 270

```python
###############################################################################
############### SIGN, ABSOLUTE VALUE, ARGUMENT and CONJUGATION ################
###############################################################################

class sign(Function):
    """
    Returns the complex sign of an expression:

    If the expresssion is real the sign will be:

        * 1 if expression is positive
        * 0 if expression is equal to zero
        * -1 if expression is negative

    If the expresssion is imaginary the sign will be:

        * I if im(expression) is positive
        * -I if im(expression) is negative

    Otherwise an unevaluated expression will be returned. When evaluated, the
    result (in general) will be ``cos(arg(expr)) + I*sin(arg(expr))``.

    Examples
    ========

    >>> from sympy.functions import sign
    >>> from sympy.core.numbers import I

    >>> sign(-1)
    -1
    >>> sign(0)
    0
    >>> sign(-3*I)
    -I
    >>> sign(1 + I)
    sign(1 + I)
    >>> _.evalf()
    0.707106781186548 + 0.707106781186548*I

    See Also
    ========

    Abs, conjugate
    """

    is_finite = True
    is_complex = True

    def doit(self, **hints):
        if self.args[0].is_zero is False:
            return self.args[0] / Abs(self.args[0])
        return self
```
### 5 - sympy/functions/elementary/complexes.py:

Start line: 272, End line: 317

```python
class sign(Function):

    @classmethod
    def eval(cls, arg):
        # handle what we can
        if arg.is_Mul:
            c, args = arg.as_coeff_mul()
            unk = []
            s = sign(c)
            for a in args:
                if a.is_negative:
                    s = -s
                elif a.is_positive:
                    pass
                else:
                    ai = im(a)
                    if a.is_imaginary and ai.is_comparable:  # i.e. a = I*real
                        s *= S.ImaginaryUnit
                        if ai.is_negative:
                            # can't use sign(ai) here since ai might not be
                            # a Number
                            s = -s
                    else:
                        unk.append(a)
            if c is S.One and len(unk) == len(args):
                return None
            return s * cls(arg._new_rawargs(*unk))
        if arg is S.NaN:
            return S.NaN
        if arg.is_zero:  # it may be an Expr that is zero
            return S.Zero
        if arg.is_positive:
            return S.One
        if arg.is_negative:
            return S.NegativeOne
        if arg.is_Function:
            if arg.func is sign:
                return arg
        if arg.is_imaginary:
            if arg.is_Pow and arg.exp is S.Half:
                # we catch this because non-trivial sqrt args are not expanded
                # e.g. sqrt(1-sqrt(2)) --x-->  to I*sqrt(sqrt(2) - 1)
                return S.ImaginaryUnit
            arg2 = -S.ImaginaryUnit * arg
            if arg2.is_positive:
                return S.ImaginaryUnit
            if arg2.is_negative:
                return -S.ImaginaryUnit
```
### 6 - sympy/printing/fcode.py:

Start line: 1, End line: 49

```python
"""
Fortran code printer

The FCodePrinter converts single sympy expressions into single Fortran
expressions, using the functions defined in the Fortran 77 standard where
possible. Some useful pointers to Fortran can be found on wikipedia:

http://en.wikipedia.org/wiki/Fortran

Most of the code below is based on the "Professional Programmer\'s Guide to
Fortran77" by Clive G. Page:

http://www.star.le.ac.uk/~cgp/prof77.html

Fortran is a case-insensitive language. This might cause trouble because
SymPy is case sensitive. The implementation below does not care and leaves
the responsibility for generating properly cased Fortran code to the user.
"""

from __future__ import print_function, division

import string

from sympy.core import S, Add, N
from sympy.core.compatibility import string_types, range
from sympy.core.function import Function
from sympy.sets import Range
from sympy.codegen.ast import Assignment
from sympy.printing.codeprinter import CodePrinter
from sympy.printing.precedence import precedence

known_functions = {
    "sin": "sin",
    "cos": "cos",
    "tan": "tan",
    "asin": "asin",
    "acos": "acos",
    "atan": "atan",
    "atan2": "atan2",
    "sinh": "sinh",
    "cosh": "cosh",
    "tanh": "tanh",
    "log": "log",
    "exp": "exp",
    "erf": "erf",
    "Abs": "Abs",
    "sign": "sign",
    "conjugate": "conjg"
}
```
### 7 - sympy/core/exprtools.py:

Start line: 102, End line: 203

```python
def _monotonic_sign(self):
    # ... other code
    if len(free) == 1:
        if self.is_polynomial():
            from sympy.polys.polytools import real_roots
            from sympy.polys.polyroots import roots
            from sympy.polys.polyerrors import PolynomialError
            x = free.pop()
            x0 = _monotonic_sign(x)
            if x0 == _eps or x0 == -_eps:
                x0 = S.Zero
            if x0 is not None:
                d = self.diff(x)
                if d.is_number:
                    roots = []
                else:
                    try:
                        roots = real_roots(d)
                    except (PolynomialError, NotImplementedError):
                        roots = [r for r in roots(d, x) if r.is_real]
                y = self.subs(x, x0)
                if x.is_nonnegative and all(r <= x0 for r in roots):
                    if y.is_nonnegative and d.is_positive:
                        if y:
                            return y if y.is_positive else Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_negative:
                        if y:
                            return y if y.is_negative else Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
                elif x.is_nonpositive and all(r >= x0 for r in roots):
                    if y.is_nonnegative and d.is_negative:
                        if y:
                            return Dummy('pos', positive=True)
                        else:
                            return Dummy('nneg', nonnegative=True)
                    if y.is_nonpositive and d.is_positive:
                        if y:
                            return Dummy('neg', negative=True)
                        else:
                            return Dummy('npos', nonpositive=True)
        else:
            n, d = self.as_numer_denom()
            den = None
            if n.is_number:
                den = _monotonic_sign(d)
            elif not d.is_number:
                if _monotonic_sign(n) is not None:
                    den = _monotonic_sign(d)
            if den is not None and (den.is_positive or den.is_negative):
                v = n*den
                if v.is_positive:
                    return Dummy('pos', positive=True)
                elif v.is_nonnegative:
                    return Dummy('nneg', nonnegative=True)
                elif v.is_negative:
                    return Dummy('neg', negative=True)
                elif v.is_nonpositive:
                    return Dummy('npos', nonpositive=True)
        return None

    # multivariate
    c, a = self.as_coeff_Add()
    v = None
    if not a.is_polynomial():
        # F/A or A/F where A is a number and F is a signed, rational monomial
        n, d = a.as_numer_denom()
        if not (n.is_number or d.is_number):
            return
        if (
                a.is_Mul or a.is_Pow) and \
                a.is_rational and \
                all(p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow) and \
                (a.is_positive or a.is_negative):
            v = S(1)
            for ai in Mul.make_args(a):
                if ai.is_number:
                    v *= ai
                    continue
                reps = {}
                for x in ai.free_symbols:
                    reps[x] = _monotonic_sign(x)
                    if reps[x] is None:
                        return
                v *= ai.subs(reps)
    elif c:
        # signed linear expression
        if not any(p for p in a.atoms(Pow) if not p.is_number) and (a.is_nonpositive or a.is_nonnegative):
            free = list(a.free_symbols)
            p = {}
            for i in free:
                v = _monotonic_sign(i)
                if v is None:
                    return
                p[i] = v or (_eps if i.is_nonnegative else -_eps)
            v = a.xreplace(p)
    if v is not None:
        rv = v + c
        if v.is_nonnegative and rv.is_positive:
            return rv.subs(_eps, 0)
        if v.is_nonpositive and rv.is_negative:
            return rv.subs(_eps, 0)
```
### 8 - sympy/functions/elementary/complexes.py:

Start line: 336, End line: 375

```python
class sign(Function):

    def _eval_is_nonnegative(self):
        if self.args[0].is_nonnegative:
            return True

    def _eval_is_nonpositive(self):
        if self.args[0].is_nonpositive:
            return True

    def _eval_is_imaginary(self):
        return self.args[0].is_imaginary

    def _eval_is_integer(self):
        return self.args[0].is_real

    def _eval_is_zero(self):
        return self.args[0].is_zero

    def _eval_power(self, other):
        if (
            fuzzy_not(self.args[0].is_zero) and
            other.is_integer and
            other.is_even
        ):
            return S.One

    def _sage_(self):
        import sage.all as sage
        return sage.sgn(self.args[0]._sage_())

    def _eval_rewrite_as_Piecewise(self, arg):
        if arg.is_real:
            return Piecewise((1, arg > 0), (-1, arg < 0), (0, True))

    def _eval_rewrite_as_Heaviside(self, arg):
        from sympy import Heaviside
        if arg.is_real:
            return Heaviside(arg)*2-1

    def _eval_simplify(self, ratio, measure):
        return self.func(self.args[0].factor())
```
### 9 - sympy/functions/special/delta_functions.py:

Start line: 535, End line: 575

```python
class Heaviside(Function):

    def _eval_rewrite_as_sign(self, arg, H0=None):
        """Represents the Heaviside function in the form of sign function.
        The value of the second argument of Heaviside must specify Heaviside(0)
        = 1/2 for rewritting as sign to be strictly equivalent.  For easier
        usage, we also allow this rewriting when Heaviside(0) is undefined.

        Examples
        ========

        >>> from sympy import Heaviside, Symbol, sign
        >>> x = Symbol('x', real=True)

        >>> Heaviside(x).rewrite(sign)
        sign(x)/2 + 1/2

        >>> Heaviside(x, 0).rewrite(sign)
        Heaviside(x, 0)

        >>> Heaviside(x - 2).rewrite(sign)
        sign(x - 2)/2 + 1/2

        >>> Heaviside(x**2 - 2*x + 1).rewrite(sign)
        sign(x**2 - 2*x + 1)/2 + 1/2

        >>> y = Symbol('y')

        >>> Heaviside(y).rewrite(sign)
        Heaviside(y)

        >>> Heaviside(y**2 - 2*y + 1).rewrite(sign)
        Heaviside(y**2 - 2*y + 1)

        See Also
        ========

        sign

        """
        if arg.is_real:
            if H0 is None or H0 == S.Half:
                return (sign(arg)+1)/2
```
### 10 - sympy/polys/subresultants_qq_zz.py:

Start line: 283, End line: 336

```python
def sylvester(f, g, x, method = 1):
    # ... other code
    if method <= 1:
        M = zeros(m + n)
        k = 0
        for i in range(n):
            j = k
            for coeff in fp:
                M[i, j] = coeff
                j = j + 1
            k = k + 1
        k = 0
        for i in range(n, m + n):
            j = k
            for coeff in gp:
                M[i, j] = coeff
                j = j + 1
            k = k + 1
        return M

    # Sylvester's matrix of 1853 (a.k.a sylvester2)
    if method >= 2:
        if len(fp) < len(gp):
            h = []
            for i in range(len(gp) - len(fp)):
                h.append(0)
            fp[ : 0] = h
        else:
            h = []
            for i in range(len(fp) - len(gp)):
                h.append(0)
            gp[ : 0] = h
        mx = max(m, n)
        dim = 2*mx
        M = zeros( dim )
        k = 0
        for i in range( mx ):
            j = k
            for coeff in fp:
                M[2*i, j] = coeff
                j = j + 1
            j = k
            for coeff in gp:
                M[2*i + 1, j] = coeff
                j = j + 1
            k = k + 1
        return M

def sign_seq(poly_seq, x):
    """
    Given a sequence of polynomials poly_seq, it returns
    the sequence of signs of the leading coefficients of
    the polynomials in poly_seq.

    """
    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]
```
